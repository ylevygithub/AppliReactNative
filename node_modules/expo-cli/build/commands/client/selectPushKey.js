'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator;

function _load_regenerator() {
  return _regenerator = _interopRequireDefault(require('babel-runtime/regenerator'));
}

var _toConsumableArray2;

function _load_toConsumableArray() {
  return _toConsumableArray2 = _interopRequireDefault(require('babel-runtime/helpers/toConsumableArray'));
}

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(require('babel-runtime/helpers/asyncToGenerator'));
}

var selectPushKey = function () {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var pushKeys, choices, autoselectedPushkey, _ref2, pushKey;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!context.username) {
              _context.next = 6;
              break;
            }

            _context.next = 3;
            return (_xdl || _load_xdl()).Credentials.Ios.getExistingPushKeys(context.username, context.team.id, {
              provideFullPushKey: true
            });

          case 3:
            _context.t0 = _context.sent;
            _context.next = 7;
            break;

          case 6:
            _context.t0 = [];

          case 7:
            pushKeys = _context.t0;
            choices = [].concat((0, (_toConsumableArray2 || _load_toConsumableArray()).default)(pushKeys));

            // autoselect creds if we find valid ones

            if (!(pushKeys.length > 0 && !options.disableAutoSelectExisting)) {
              _context.next = 13;
              break;
            }

            autoselectedPushkey = (0, (_selectUtils || _load_selectUtils()).choosePreferredCreds)(context, pushKeys);

            (0, (_log || _load_log()).default)('Using Push Key: ' + autoselectedPushkey.name);
            return _context.abrupt('return', autoselectedPushkey.value);

          case 13:

            if (!options.disableCreate) {
              choices.push({ name: '[Create a new key]', value: 'GENERATE' });
            }
            choices.push({ name: '[Upload an existing key]', value: 'UPLOAD' });

            _context.next = 17;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'pushKey',
              message: 'Select an authentication token signing key to use for push notifications:',
              pageSize: Infinity,
              choices: choices
            });

          case 17:
            _ref2 = _context.sent;
            pushKey = _ref2.pushKey;

            if (!(pushKey === 'GENERATE')) {
              _context.next = 25;
              break;
            }

            _context.next = 22;
            return generatePushKey(context);

          case 22:
            pushKey = _context.sent;
            _context.next = 29;
            break;

          case 25:
            if (!(pushKey === 'UPLOAD')) {
              _context.next = 29;
              break;
            }

            _context.next = 28;
            return (0, (_promptForCredentials || _load_promptForCredentials()).default)(context, ['pushKey']);

          case 28:
            pushKey = _context.sent[0].pushKey;

          case 29:
            return _context.abrupt('return', pushKey);

          case 30:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function selectPushKey(_x) {
    return _ref.apply(this, arguments);
  };
}();

var generatePushKey = function () {
  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)( /*#__PURE__*/(_regenerator || _load_regenerator()).default.mark(function _callee2(context) {
    var manager, keys, _ref4, answer;

    return (_regenerator || _load_regenerator()).default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            manager = (_appleApi || _load_appleApi()).createManagers(context).pushKey;
            _context2.prev = 1;
            _context2.next = 4;
            return manager.create({});

          case 4:
            return _context2.abrupt('return', _context2.sent);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2['catch'](1);

            if (!(_context2.t0.code === 'APPLE_KEYS_TOO_MANY_GENERATED_ERROR')) {
              _context2.next = 30;
              break;
            }

            _context2.next = 12;
            return manager.list();

          case 12:
            keys = _context2.sent;

            (_log || _load_log()).default.warn('Maximum number (' + keys.length + ') of keys generated.');
            _context2.next = 16;
            return (0, (_prompt || _load_prompt()).default)({
              type: 'list',
              name: 'answer',
              message: 'Please revoke or reuse an existing key:',
              choices: [{
                key: 'r',
                name: 'Choose which keys to revoke',
                value: 'REVOKE'
              }, {
                key: 'e',
                name: 'Use an existing key',
                value: 'USE_EXISTING'
              }]
            });

          case 16:
            _ref4 = _context2.sent;
            answer = _ref4.answer;

            if (!(answer === 'REVOKE')) {
              _context2.next = 26;
              break;
            }

            _context2.next = 21;
            return (_credentials || _load_credentials()).revoke(context, ['pushKey']);

          case 21:
            _context2.next = 23;
            return generatePushKey(context);

          case 23:
            return _context2.abrupt('return', _context2.sent);

          case 26:
            if (!(answer === 'USE_EXISTING')) {
              _context2.next = 30;
              break;
            }

            _context2.next = 29;
            return selectPushKey(context, {
              disableCreate: true,
              disableAutoSelectExisting: true
            });

          case 29:
            return _context2.abrupt('return', _context2.sent);

          case 30:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[1, 7]]);
  }));

  return function generatePushKey(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var _xdl;

function _load_xdl() {
  return _xdl = require('xdl');
}

var _appleApi;

function _load_appleApi() {
  return _appleApi = _interopRequireWildcard(require('../build/ios/appleApi'));
}

var _credentials;

function _load_credentials() {
  return _credentials = _interopRequireWildcard(require('../build/ios/credentials'));
}

var _promptForCredentials;

function _load_promptForCredentials() {
  return _promptForCredentials = _interopRequireDefault(require('../build/ios/credentials/prompt/promptForCredentials'));
}

var _log;

function _load_log() {
  return _log = _interopRequireDefault(require('../../log'));
}

var _prompt;

function _load_prompt() {
  return _prompt = _interopRequireDefault(require('../../prompt'));
}

var _selectUtils;

function _load_selectUtils() {
  return _selectUtils = require('./selectUtils');
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// XXX: workaround for https://github.com/babel/babel/issues/6262
exports.default = selectPushKey;
module.exports = exports['default'];
//# sourceMappingURL=../../__sourcemaps__/commands/client/selectPushKey.js.map
