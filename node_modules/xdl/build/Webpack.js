'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.openAsync = exports.bundleAsync = exports.stopAsync = exports.getProtocolAsync = exports.getUrlAsync = exports.startAsync = undefined;

let choosePortAsync = (() => {
  var _ref = _asyncToGenerator(function* () {
    try {
      return yield (0, (_WebpackDevServerUtils || _load_WebpackDevServerUtils()).choosePort)(HOST, DEFAULT_PORT);
    } catch (error) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.NO_PORT_FOUND, 'No available port found: ' + error.message);
    }
  });

  return function choosePortAsync() {
    return _ref.apply(this, arguments);
  };
})();

let startAsync = exports.startAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, { nonInteractive }, verbose) {
    yield (_Doctor || _load_Doctor()).validateWebSupportAsync(projectRoot);

    if (webpackDevServerInstance) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is already running.');
      return;
    }

    const useYarn = (_config || _load_config()).isUsingYarn(projectRoot);

    const { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    const { webName } = (_config || _load_config()).getNameFromConfig(exp);

    let { dev, https } = yield (_ProjectSettings || _load_ProjectSettings()).readAsync(projectRoot);
    const mode = dev ? 'development' : 'production';

    const config = (_Web || _load_Web()).invokeWebpackConfig({
      projectRoot,
      pwa: true,
      development: dev,
      production: !dev,
      https
    });

    webpackServerPort = yield choosePortAsync();
    (_ProjectUtils || _load_ProjectUtils()).logInfo(projectRoot, WEBPACK_LOG_TAG, `Starting Webpack on port ${webpackServerPort} in ${(_chalk || _load_chalk()).default.underline(mode)} mode.`);

    const protocol = https ? 'https' : 'http';
    const urls = (0, (_WebpackDevServerUtils || _load_WebpackDevServerUtils()).prepareUrls)(protocol, '::', webpackServerPort);

    yield new Promise(function (resolve) {
      // Create a webpack compiler that is configured with custom messages.
      const compiler = (0, (_createWebpackCompiler || _load_createWebpackCompiler()).default)({
        projectRoot,
        nonInteractive,
        webpack: (_webpack || _load_webpack()).default,
        appName: webName,
        config,
        urls,
        useYarn,
        onFinished: resolve
      });
      webpackDevServerInstance = new (_webpackDevServer || _load_webpackDevServer()).default(compiler, config.devServer);
      // Launch WebpackDevServer.
      webpackDevServerInstance.listen(webpackServerPort, HOST, function (error) {
        if (error) {
          (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, WEBPACK_LOG_TAG, error);
        }
        // clearConsole();
      });
    });

    yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
      webpackServerPort
    });

    return {
      server: webpackDevServerInstance,
      url: yield getUrlAsync(projectRoot)
    };
  });

  return function startAsync(_x, _x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

let getUrlAsync = exports.getUrlAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot) {
    const devServer = getServer(projectRoot);
    if (!devServer) {
      return null;
    }
    const host = (_ip || _load_ip()).default.address();
    const urlType = yield getProtocolAsync(projectRoot);
    return `${urlType}://${host}:${webpackServerPort}`;
  });

  return function getUrlAsync(_x4) {
    return _ref3.apply(this, arguments);
  };
})();

let getProtocolAsync = exports.getProtocolAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (projectRoot) {
    // TODO: Bacon: Handle when not in expo
    const { https } = yield (_ProjectSettings || _load_ProjectSettings()).readAsync(projectRoot);
    if (https === true) {
      return 'https';
    }
    return 'http';
  });

  return function getProtocolAsync(_x5) {
    return _ref4.apply(this, arguments);
  };
})();

let stopAsync = exports.stopAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (projectRoot) {
    if (webpackDevServerInstance) {
      yield new Promise(function (resolve) {
        return webpackDevServerInstance.close(function () {
          return resolve();
        });
      });
      webpackDevServerInstance = null;
      webpackServerPort = null;
      // TODO
      yield (_ProjectSettings || _load_ProjectSettings()).setPackagerInfoAsync(projectRoot, {
        webpackServerPort: null
      });
    }
  });

  return function stopAsync(_x6) {
    return _ref5.apply(this, arguments);
  };
})();

let bundleAsync = exports.bundleAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (projectRoot, packagerOpts) {
    yield (_Doctor || _load_Doctor()).validateWebSupportAsync(projectRoot);
    const mode = packagerOpts.dev ? 'development' : 'production';
    process.env.BABEL_ENV = mode;
    process.env.NODE_ENV = mode;

    let config = (_Web || _load_Web()).invokeWebpackConfig({
      projectRoot,
      pwa: packagerOpts.pwa,
      polyfill: packagerOpts.polyfill,
      development: packagerOpts.dev,
      production: !packagerOpts.dev
    });
    let compiler = (0, (_webpack || _load_webpack()).default)(config);

    try {
      // We generate the stats.json file in the webpack-config
      yield new Promise(function (resolve, reject) {
        return compiler.run((() => {
          var _ref7 = _asyncToGenerator(function* (error, stats) {
            // TODO: Bacon: account for CI
            if (error) {
              // TODO: Bacon: Clean up error messages
              return reject(error);
            }
            resolve(stats);
          });

          return function (_x9, _x10) {
            return _ref7.apply(this, arguments);
          };
        })());
      });
    } catch (error) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', 'There was a problem building your web project. ' + error.message);
      throw error;
    }
  });

  return function bundleAsync(_x7, _x8) {
    return _ref6.apply(this, arguments);
  };
})();

let openAsync = exports.openAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectRoot, options = {}, verbose = true) {
    if (!webpackDevServerInstance) {
      yield startAsync(projectRoot, options, verbose);
    }
    yield (_Web || _load_Web()).openProjectAsync(projectRoot);
  });

  return function openAsync(_x11) {
    return _ref8.apply(this, arguments);
  };
})();

exports.getServer = getServer;

var _config;

function _load_config() {
  return _config = _interopRequireWildcard(require('@expo/config'));
}

var _WebpackDevServerUtils;

function _load_WebpackDevServerUtils() {
  return _WebpackDevServerUtils = require('react-dev-utils/WebpackDevServerUtils');
}

var _webpack;

function _load_webpack() {
  return _webpack = _interopRequireDefault(require('webpack'));
}

var _webpackDevServer;

function _load_webpackDevServer() {
  return _webpackDevServer = _interopRequireDefault(require('webpack-dev-server'));
}

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

var _createWebpackCompiler;

function _load_createWebpackCompiler() {
  return _createWebpackCompiler = _interopRequireDefault(require('./createWebpackCompiler'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _Web;

function _load_Web() {
  return _Web = _interopRequireWildcard(require('./Web'));
}

var _Doctor;

function _load_Doctor() {
  return _Doctor = _interopRequireWildcard(require('./project/Doctor'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

var _ip;

function _load_ip() {
  return _ip = _interopRequireDefault(require('./ip'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

//eslint-disable-line

const HOST = '0.0.0.0';
const DEFAULT_PORT = 19006;
const WEBPACK_LOG_TAG = 'expo';

let webpackDevServerInstance = null;
let webpackServerPort = null;

function getServer(projectRoot) {
  if (webpackDevServerInstance == null) {
    (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is not running.');
  }
  return webpackDevServerInstance;
}
//# sourceMappingURL=__sourcemaps__/Webpack.js.map
