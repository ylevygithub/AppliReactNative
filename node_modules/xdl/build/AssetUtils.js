'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNewFilename = exports.readAssetJsonAsync = exports.getAssetFilesAsync = exports.hasUnoptimizedAssetsAsync = exports.optimizeImageAsync = exports.calculateHash = exports.toReadableValue = undefined;

var _fs = _interopRequireDefault(require('fs'));

var _path = _interopRequireDefault(require('path'));

var _crypto = _interopRequireDefault(require('crypto'));

var _chalk;

function _load_chalk() {
  return _chalk = _interopRequireDefault(require('chalk'));
}

var _sharp;

function _load_sharp() {
  return _sharp = _interopRequireDefault(require('sharp'));
}

var _glob;

function _load_glob() {
  return _glob = _interopRequireDefault(require('glob'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = require('./project/ProjectUtils');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/*
 * Converts a raw number of bytes into a human readable value
 */
const toReadableValue = exports.toReadableValue = bytes => {
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const index = Math.floor(Math.log(bytes) / Math.log(1024));
  const reduced = (bytes / Math.pow(1024, index)).toFixed(2) * 1;

  return `${reduced} ${sizes[index]}`;
};

/*
 * Calculate SHA256 Checksum value of a file based on its contents
 */
const calculateHash = exports.calculateHash = file => {
  const contents = _fs.default.readFileSync(file);
  return _crypto.default.createHash('sha256').update(contents).digest('hex');
};

/*
 * Compress an inputted jpg or png
 */
const optimizeImageAsync = exports.optimizeImageAsync = (() => {
  var _ref = _asyncToGenerator(function* (image, newName, quality) {
    (_Logger || _load_Logger()).default.global.info(`Optimizing ${image}`);
    _fs.default.copyFileSync(image, newName);

    // Extract the format and compress
    const buffer = yield (0, (_sharp || _load_sharp()).default)(image).toBuffer();
    const { format } = yield (0, (_sharp || _load_sharp()).default)(buffer).metadata();
    if (format === 'jpeg') {
      yield (0, (_sharp || _load_sharp()).default)(newName).jpeg({ quality }).toFile(image).catch(function (err) {
        return (_Logger || _load_Logger()).default.global.error(err);
      });
    } else {
      yield (0, (_sharp || _load_sharp()).default)(newName).png({ quality }).toFile(image).catch(function (err) {
        return (_Logger || _load_Logger()).default.global.error(err);
      });
    }
  });

  return function optimizeImageAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

/*
 * Returns a boolean indicating whether or not there are assets to optimize
 */
const hasUnoptimizedAssetsAsync = exports.hasUnoptimizedAssetsAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectDir, options) {
    if (!_fs.default.existsSync(_path.default.join(projectDir, '.expo-shared/assets.json'))) {
      return true;
    }
    const { selectedFiles } = yield getAssetFilesAsync(projectDir, options);
    const { assetInfo } = yield readAssetJsonAsync(projectDir);

    for (const file of selectedFiles) {
      const hash = calculateHash(file);
      if (!assetInfo[hash]) {
        return true;
      }
    }

    return false;
  });

  return function hasUnoptimizedAssetsAsync(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
})();

/*
 * Find all project assets under assetBundlePatterns in app.json excluding node_modules.
 * If --include of --exclude flags were passed in those results are filtered out.
 */
const getAssetFilesAsync = exports.getAssetFilesAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectDir, options) {
    const { exp } = yield (0, (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync)(projectDir);
    const { assetBundlePatterns } = exp;
    const globOptions = {
      cwd: projectDir,
      ignore: ['**/node_modules/**', '**/ios/**', '**/android/**']
    };

    // All files must be returned even if flags are passed in to properly update assets.json
    const allFiles = [];
    assetBundlePatterns.forEach(function (pattern) {
      allFiles.push(...(_glob || _load_glob()).default.sync(pattern, globOptions));
    });
    // If --include is passed in, only return files matching that pattern
    const included = options.include ? [...(_glob || _load_glob()).default.sync(options.include, globOptions)] : allFiles;
    const toExclude = new Set();
    if (options.exclude) {
      (_glob || _load_glob()).default.sync(options.exclude, globOptions).forEach(function (file) {
        return toExclude.add(file);
      });
    }
    // If --exclude is passed in, filter out files matching that pattern
    const excluded = included.filter(function (file) {
      return !toExclude.has(file);
    });
    const filtered = options.exclude ? excluded : included;
    return {
      allFiles: filterImages(allFiles, projectDir),
      selectedFiles: filterImages(filtered, projectDir)
    };
  });

  return function getAssetFilesAsync(_x6, _x7) {
    return _ref3.apply(this, arguments);
  };
})();

/*
 * Formats an array of files to include the project directory and filters out PNGs and JPGs.
 */
const filterImages = (files, projectDir) => {
  const regex = /\.(png|jpg|jpeg)$/;
  const withDirectory = files.map(file => `${projectDir}/${file}`.replace('//', '/'));
  const allImages = withDirectory.filter(file => regex.test(file.toLowerCase()));
  return allImages;
};

/*
 * Read the contents of assets.json under .expo-shared folder. Create the file/directory if they don't exist.
 */
const readAssetJsonAsync = exports.readAssetJsonAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (projectDir) {
    const dirPath = _path.default.join(projectDir, '.expo-shared');
    if (!_fs.default.existsSync(dirPath)) {
      _fs.default.mkdirSync(dirPath);
    }

    const assetJson = new (_jsonFile || _load_jsonFile()).default(_path.default.join(dirPath, 'assets.json'));
    if (!_fs.default.existsSync(assetJson.file)) {
      const message = `Creating ${(_chalk || _load_chalk()).default.italic('.expo-shared/assets.json')} in the project's root directory.\n` + `This file is autogenerated and should not be edited directly.\n` + 'You should commit this to git so that asset state is shared between collaborators.';

      (_Logger || _load_Logger()).default.global.info(message);

      yield assetJson.writeAsync({});
    }
    const assetInfo = yield assetJson.readAsync();
    return { assetJson, assetInfo };
  });

  return function readAssetJsonAsync(_x8) {
    return _ref4.apply(this, arguments);
  };
})();

/*
 * Add .orig extension to a filename in a path string
 */
const createNewFilename = exports.createNewFilename = image => {
  const { dir, name, ext } = _path.default.parse(image);
  return dir + '/' + name + '.orig' + ext;
};
//# sourceMappingURL=__sourcemaps__/AssetUtils.js.map
